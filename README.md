Egg
=====================

Разработка
--------------------

Перед началом работы, необходимо необходимо подготовить систему - нам
понадобятся git и Erlang-19+:

>       $ wget
        https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb
>       $ sudo dpkg -i erlang-solutions_1.0_all.deb
>       $ sudo apt-get update
>       $ sudo apt-get install erlang git

Теперь система готова к работе, клонируем egg:

>       $ git clone https://github.com/kimoffegg/egg.git

Запускаем сервер:

>       $ cd egg && rebar3 run

Для остановки сервера

>       $ q().

Использование
--------------------

Деплой на продакшн производится следующим образом:
Собираем релиз:

>       $ ./rebar3 as prod tar

В конце сборки получаем сообщение следующего вида:

>       ===> tarball $PATH_TO_RELEASE.tar.gz successfully created!

Заливаем тарбол на сервер, например так:

>       scp -i "$PATH_TO_KEY.pem" $PATH_TO_RELEASE.tar.gz user@remote_host:/home/user/egg

Заходим на удалённый сервер (свежая система, устанавливать ничего не нужно) разархивируем тарбол и запускаем его:

>       cd egg && tar -xf egg-0.0.1.tar.gz
>       ./bin/egg start

Чтобы проверить, что сервер работает, можно написать:

>       ./bin/egg ping

должен вернуть "pong"

Конфигурирование
----------------------

Хостинг статических файлов
----------------------

В файле egg/apps/server/src/server.app.src в поле static_dir
указывается раположение статических файлов, доступ к которым будет
предоставлять эта машина по пути myhost.com:8080/static/*

Регистрация
----------------------

В свежей системе нет пользователей, поэтому нужно создать первого администратора из консоли сервера командой:

>       %% new(Login, Pwd, Name, Group, AccessLevel)
>       users:new(<<"admin">>, <<"my_password">>, <<"MyName">>, administrators, 0).

Таким же образом можно создавать и обычных пользователей, поменяв группу на users, а можно послать POST с JSON с полями login, password_hash, name, group, access_level на адресс ../v1/register, либо зайдя по этому адрессу и заполнив форму. Регистрация новых пользователей, пока что, доступна только авторизованным пользователям группы administrators с уровнем доступа не выше 100.

Аплоад и загрузка файлов
----------------------

WebSocket
----------------------

Авторизация производится отправкой JSON по адрессу ../v1/auth с полями login и password, где поле password хранит md5 хэш пароля, либо через форму, по этому-же адресу. В случае успешной авторизации вы получаете session_id, который и будет в дальнейшем давать вам доступ, ставя обращение к нему префиксом к запросу, требующему авторизации. Пример:

Неавторизованный доступ к модулю регистрации:

>       localhost:8080/v1/register

Авторизованный доступ к модулю регистрации:

>       localhost:8080/v1/session/$SESSION_ID/register

Аплоад и загрузка файлов
----------------------

WebSocket
----------------------

Вебсокет как и REST оформлен модульно - строка запроса будет распарсена, опознанна сессия, модуль протокола, у модуля будут запрошены уровни и группы, имеющие доступ к нему, и если пользователь имеет достаточно прав - открыт вебсокет на одном из транспортов, обозначенных пользователем и сервером как поддерживаемые (сейчас это JSON и MsgPack, значение передаётся в хэдере 'sec-websocket-protocol' запроса открытия вебсокета). Формат адресной строки открытия вебсокета:

>       localhost:8080/ws/$VERSION/$PROTOCOL

Либо, для авторизованного доступа:

>       localhost:8080/session/$SESSION_ID/ws/$VERSION/$PROTOCOL

На данный момент существуют протоколы default (для тестов и отладки) и chat.

Устройство модуля-протокола:
Каждый модуль-протокол должен реализовать 6 функций:
* access_level - возвращает уровень доступа к модулю
* allowed_groups - возвращает список групп, имеющих доступ к модулю
* wrap_msg - преобразовывает ответ сервера в бинарный формат согласно оговоренному транспорту
* do_action - описывает действия, основанные на полученном от клиента сообщении и стэйте пользователя
* unwrap_msg - преобразовывает сообщение клиента из бинарного формата в типизированный внутренний формат сервера
* default_user_state - конструктор начального стэйта пользователя на основании данных о сессии

Администрирование
----------------------

Бэкапы и восстановление
----------------------
